name: Monitor1 URL Changes

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/monitor1.yml'
      - 'url_state1.json'
  schedule:
    - cron: '0 23,0-13 * * *'

permissions:
  contents: write

jobs:
  check_url_changes:
    runs-on: ubuntu-latest
    env:
      WECHAT_APP_ID: ${{ secrets.WECHAT_APP_ID }}
      WECHAT_APP_SECRET: ${{ secrets.WECHAT_APP_SECRET }}
      WECHAT_TEMPLATE_ID: ${{ secrets.WECHAT_TEMPLATE_ID }}
      WECHAT_TO_USER: ${{ secrets.WECHAT_TO_USER }}
      CHECK_URLS: |
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512
        https://github.com/rzhy1/aria2-static-build/blob/main/.github/workflows/build_and_release.yml
      URL_DESCRIPTIONS: |
        {"https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331": "æ­å·åœ°é“æ‹›æ ‡è®¡åˆ’å‘å¸ƒ",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332": "æ­å·åœ°é“æ‹›æ ‡é¢„å…¬ç¤º",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508": "æ­å·åœ°é“ç‰¹åˆ«æé†’é¡¹ç›®",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509": "æ­å·åœ°é“æ‹›æ ‡æ ¸å‡†é¡¹ç›®",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510": "æ­å·åœ°é“æ‹›æ ‡æ–‡ä»¶å…¬ç¤º",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511": "æ­å·åœ°é“ä¸­æ ‡å…¬ç¤º",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512": "æ­å·åœ°é“ä¸­æ ‡ç»“æœ",
         "https://github.com/rzhy1/aria2-static-build/blob/main/.github/workflows/build_and_release.yml": "æµ‹è¯•ä¸“ç”¨"}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 urllib3

      - name: Check and notify
        run: |
          python - << "EOF"
          import os
          import json
          import hashlib
          import time
          import re
          import requests
          from bs4 import BeautifulSoup
          
          STATE_FILE = "url_state1.json"
          USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"

          class Monitor:
              def __init__(self):
                  self.session = requests.Session()
                  self.check_urls = [u.strip() for u in os.getenv("CHECK_URLS").splitlines() if u.strip()]
                  self.url_descriptions = json.loads(os.getenv("URL_DESCRIPTIONS"))
                  self.wechat_app_id = os.getenv("WECHAT_APP_ID")
                  self.wechat_app_secret = os.getenv("WECHAT_APP_SECRET")
                  self.wechat_template_id = os.getenv("WECHAT_TEMPLATE_ID")
                  self.wechat_to_user = os.getenv("WECHAT_TO_USER")

              def extract_project_titles(self, html, current_url):
                  """æå–é¡¹ç›®æ ‡é¢˜å’Œé“¾æ¥"""
                  soup = BeautifulSoup(html, 'html.parser')
                  titles_with_links = []
                  
                  # å°è¯•å¤šç§é€‰æ‹©å™¨
                  selectors = [
                      'div.menu.menu_time',
                      'div.list > div',
                      '.listWrap .list > div'
                  ]
                  
                  menu_divs = []
                  for selector in selectors:
                      menu_divs = soup.select(selector)
                      if menu_divs:
                          break
                  
                  if not menu_divs:
                      menu_divs = soup.find_all('div', onclick=lambda x: x and 'window.open' in x)
                  
                  for div in menu_divs:
                      title_element = div.find('h3') or div.find('a') or div
                      title_text = title_element.get_text(strip=True)
                      
                      if not title_text or len(title_text) < 5:
                          continue
                          
                      # æå–é“¾æ¥
                      onclick = div.get('onclick', '')
                      detail_url = current_url
                      
                      if onclick and 'window.open' in onclick:
                          match = re.search(r"window\.open\s*\(\s*['\"]([^'\"]+)['\"]", onclick)
                          if match:
                              detail_path = match.group(1)
                              if detail_path.startswith('/'):
                                  detail_url = f"https://ztb.cxjw.hangzhou.gov.cn:8092{detail_path}"
                              else:
                                  detail_url = detail_path
                      
                      titles_with_links.append((title_text, detail_url))
                  
                  return titles_with_links

              def get_content_hash(self, url):
                  try:
                      r = self.session.get(url, headers={'User-Agent': USER_AGENT}, timeout=10)
                      r.raise_for_status()
                      
                      # æå–é¡¹ç›®æ ‡é¢˜
                      titles_with_links = self.extract_project_titles(r.text, url)
                      sorted_titles = sorted([title for title, link in titles_with_links])
                      content_for_hash = "\n".join(sorted_titles)
                      
                      return hashlib.sha256(content_for_hash.encode()).hexdigest(), titles_with_links
                  except Exception as e:
                      print(f"[ERROR] {url} è·å–å¤±è´¥: {e}")
                      return None, []

              def load_state(self):
                if os.path.exists(STATE_FILE):
                    try:
                        with open(STATE_FILE, 'r', encoding='utf-8') as f:
                            return json.load(f)
                    except json.JSONDecodeError:
                        print(f"[WARN] {STATE_FILE} å†…å®¹æ ¼å¼é”™è¯¯ï¼Œå·²é‡ç½®ä¸ºç©º JSON")
                        return {}
                return {}

              def save_state(self, state):
                  with open(STATE_FILE, 'w', encoding='utf-8') as f:
                      json.dump(state, f, ensure_ascii=False, indent=2)

              def get_wechat_access_token(self):
                  url = f"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={self.wechat_app_id}&secret={self.wechat_app_secret}"
                  try:
                      r = self.session.get(url, timeout=10).json()
                      return r.get("access_token")
                  except Exception as e:
                      print(f"[ERROR] è·å– access_token å¤±è´¥: {e}")
                      return None

              def truncate_content(self, content, max_length=180):
                  """æˆªæ–­å†…å®¹ï¼Œç¡®ä¿ä¸è¶…è¿‡å¾®ä¿¡å­—æ®µé™åˆ¶"""
                  if len(content) <= max_length:
                      return content
                  # æˆªæ–­å¹¶æ·»åŠ çœç•¥å·
                  return content[:max_length-3] + "..."

              def send_wechat_template_message(self, access_token, title, new_titles, all_titles, url_desc):
                  """å‘é€å¾®ä¿¡æ¨¡æ¿æ¶ˆæ¯ - å¤„ç†å†…å®¹æˆªæ–­é—®é¢˜"""
                  send_url = f"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={access_token}"
                  
                  # æ„å»ºæ–°å¢å†…å®¹ï¼Œé™åˆ¶é•¿åº¦
                  if new_titles:
                      # åªæ˜¾ç¤ºå‰5æ¡æ–°å¢å†…å®¹ï¼Œé¿å…è¿‡é•¿
                      new_titles_display = new_titles[:5]
                      new_content = "\n".join([f"ğŸ”´ {title}" for title in new_titles_display])
                      if len(new_titles) > 5:
                          new_content += f"\n...ç­‰{len(new_titles)}æ¡æ–°å¢"
                  else:
                      new_content = "é¡µé¢å†…å®¹æœ‰å˜åŒ–ï¼Œä½†æœªæ£€æµ‹åˆ°å…·ä½“æ–°å¢æ ‡é¢˜"
                  
                  # ç¡®ä¿å†…å®¹ä¸è¶…è¿‡å¾®ä¿¡é™åˆ¶
                  new_content = self.truncate_content(new_content, 180)
                  
                  # æ ¹æ®æ‚¨çš„æ¨¡æ¿ç»“æ„è°ƒæ•´å­—æ®µ
                  data = {
                      "touser": self.wechat_to_user,
                      "template_id": self.wechat_template_id,
                      "url": url_desc,
                      "data": {
                          "first": {
                              "value": self.truncate_content(f"ğŸš¨ {title} å‘ç°{len(new_titles)}æ¡æ–°å¢", 50),
                              "color": "#FF0000"
                          },
                          "keyword1": {
                              "value": new_content,
                              "color": "#173177"
                          },
                          "keyword2": {
                              "value": time.strftime('%Y-%m-%d %H:%M:%S'),
                              "color": "#173177"
                          },
                          "remark": {
                              "value": self.truncate_content(f"ç‚¹å‡»æŸ¥çœ‹å®Œæ•´å†…å®¹ï¼Œå…±{len(all_titles)}æ¡", 50),
                              "color": "#173177"
                          }
                      }
                  }
                  
                  print(f"è°ƒè¯•ä¿¡æ¯ - æ–°å¢å†…å®¹é•¿åº¦: {len(new_content)}")
                  print(f"è°ƒè¯•ä¿¡æ¯ - æ–°å¢å†…å®¹é¢„è§ˆ: {new_content[:100]}...")
                  
                  try:
                      r = self.session.post(send_url, json=data, timeout=15).json()
                      if r.get("errcode") == 0:
                          print(f"âœ… å¾®ä¿¡æ¶ˆæ¯å‘é€æˆåŠŸ: {title}")
                          return True
                      else:
                          print(f"âŒ å¾®ä¿¡æ¶ˆæ¯å‘é€å¤±è´¥: {r.get('errmsg')}")
                          return False
                  except Exception as e:
                      print(f"[ERROR] å¾®ä¿¡æ¶ˆæ¯å‘é€å¼‚å¸¸: {e}")
                      return False

              def run(self):
                  prev_state = self.load_state()
                  curr_state = {}
                  changed_urls = []

                  access_token = self.get_wechat_access_token()
                  if not access_token:
                      print("æ— æ³•è·å–å¾®ä¿¡ access_tokenï¼Œé€€å‡º")
                      return

                  for url in self.check_urls:
                      print(f"\næ£€æŸ¥: {url}")
                      curr_hash, titles_with_links = self.get_content_hash(url)
                      if curr_hash is None:
                          continue
                          
                      prev_hash = prev_state.get(url, {}).get("hash")
                      prev_titles = prev_state.get(url, {}).get("titles", [])

                      if curr_hash != prev_hash:
                          # æ‰¾å‡ºæ–°å¢çš„æ ‡é¢˜ï¼ˆåªæ¯”è¾ƒæ ‡é¢˜æ–‡æœ¬ï¼‰
                          current_title_texts = [title for title, link in titles_with_links]
                          new_titles = [title for title in current_title_texts if title not in prev_titles]
                          
                          if new_titles or curr_hash != prev_hash:
                              print(f"å‘ç° {len(new_titles)} ä¸ªæ–°å¢æ ‡é¢˜: {new_titles}")
                              desc = self.url_descriptions.get(url, "é¡µé¢æ›´æ–°")
                              self.send_wechat_template_message(access_token, desc, new_titles, titles_with_links, url)
                          
                          changed_urls.append(url)

                      # ä¿å­˜å½“å‰çŠ¶æ€ï¼ˆåªä¿å­˜æ ‡é¢˜æ–‡æœ¬ï¼Œä¸ä¿å­˜é“¾æ¥ï¼‰
                      curr_state[url] = {
                          "hash": curr_hash,
                          "titles": [title for title, link in titles_with_links]
                      }
                      time.sleep(1)

                  self.save_state(curr_state)
                  print(f"æ£€æŸ¥å®Œæˆï¼Œå…±æ›´æ–° {len(changed_urls)} ä¸ª URL")

          if __name__ == "__main__":
              Monitor().run()
          EOF

      - name: Commit and push state file
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          if git diff --quiet url_state1.json; then
            echo "No changes detected in url_state1.json."
          else
            git add url_state1.json
            git commit -m "Update URL states [skip ci]" || echo "No changes to commit."
            git push origin HEAD || echo "Push failed"
          fi
