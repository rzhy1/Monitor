name: Monitor URL Changes

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 23,0-13 * * *'

permissions:
  contents: write

jobs:
  check_url_changes:
    runs-on: ubuntu-latest
    env:
      WECHAT_APP_ID: ${{ secrets.WECHAT_APP_ID }}
      WECHAT_APP_SECRET: ${{ secrets.WECHAT_APP_SECRET }}
      WECHAT_TEMPLATE_ID: ${{ secrets.WECHAT_TEMPLATE_ID }}
      WECHAT_TO_USER: ${{ secrets.WECHAT_TO_USER }}
      CHECK_URLS: |
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512
        https://github.com/rzhy1/aria2-static-build/blob/main/.github/workflows/build_and_release.yml
      URL_DESCRIPTIONS: |
        {"https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331": "杭州地铁招标计划发布",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332": "杭州地铁招标预公示",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508": "杭州地铁特别提醒项目",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509": "杭州地铁招标核准项目",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510": "杭州地铁招标文件公示",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511": "杭州地铁中标公示",
         "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512": "杭州地铁中标结果",
         "https://github.com/rzhy1/aria2-static-build/blob/main/.github/workflows/build_and_release.yml": "测试专用"}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install \
            requests \
            beautifulsoup4 \
            urllib3

      - name: Check and notify
        run: |
          python - << "EOF"
          import os
          import json
          import hashlib
          import time
          import re
          import requests
          from bs4 import BeautifulSoup, Comment
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          # 常量配置
          USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
          STATE_FILE = "url_state1.json"

          class Monitor:
              def __init__(self):
                  self.session = self.create_session()
                  self.url_descriptions = json.loads(os.getenv("URL_DESCRIPTIONS"))
                  self.check_urls = [u.strip() for u in os.getenv("CHECK_URLS").splitlines() if u.strip()]
                  self.base_url = "https://ztb.cxjw.hangzhou.gov.cn:8092"
                  # 微信测试号配置
                  self.wechat_app_id = os.getenv("WECHAT_APP_ID")
                  self.wechat_app_secret = os.getenv("WECHAT_APP_SECRET")
                  self.wechat_template_id = os.getenv("WECHAT_TEMPLATE_ID")
                  self.wechat_to_user = os.getenv("WECHAT_TO_USER")  # 接收者的OpenID

              def create_session(self):
                  """创建带重试机制的会话"""
                  session = requests.Session()
                  retry = Retry(
                      total=3,
                      backoff_factor=1,
                      status_forcelist=[429, 500, 502, 503, 504],
                      allowed_methods=['GET']
                  )
                  adapter = HTTPAdapter(max_retries=retry)
                  session.mount('https', adapter)
                  session.mount('http', adapter)
                  return session

              def extract_project_titles(self, html, current_url):
                  """提取项目标题和链接 - 使用更灵活的选择器"""
                  soup = BeautifulSoup(html, 'html.parser')
                  titles_with_links = []
                  
                  # 尝试多种可能的选择器
                  selectors = [
                      'div.menu.menu_time',
                      'div.list > div',  # 直接获取列表下的div
                      '.listWrap .list > div'  # 更具体的选择器
                  ]
                  
                  menu_divs = []
                  for selector in selectors:
                      menu_divs = soup.select(selector)
                      if menu_divs:
                          print(f"使用选择器 '{selector}' 找到了 {len(menu_divs)} 个元素")
                          break
                  
                  if not menu_divs:
                      print("警告: 未找到任何项目元素，尝试备用选择器")
                      # 备用方案: 查找包含onclick的div
                      menu_divs = soup.find_all('div', onclick=lambda x: x and 'window.open' in x)
                      print(f"备用选择器找到了 {len(menu_divs)} 个元素")
                  
                  print(f"总共找到 {len(menu_divs)} 个可能的项目元素")
                  
                  for i, div in enumerate(menu_divs):
                      # 优先查找h3，如果没有则查找其他可能包含标题的标签
                      title_element = div.find('h3') or div.find('a') or div
                      title_text = title_element.get_text(strip=True)
                      
                      # 过滤掉空标题或非项目标题
                      if not title_text or len(title_text) < 5:
                          continue
                          
                      print(f"项目 {i+1}: {title_text}")
                      
                      # 尝试从onclick属性中提取链接
                      onclick = div.get('onclick', '')
                      detail_url = None
                      
                      if onclick and 'window.open' in onclick:
                          # 使用正则表达式提取URL
                          match = re.search(r"window\.open\s*\(\s*['\"]([^'\"]+)['\"]", onclick)
                          if match:
                              detail_path = match.group(1)
                              # 构建完整URL
                              if detail_path.startswith('/'):
                                  detail_url = f"{self.base_url}{detail_path}"
                              else:
                                  detail_url = detail_path
                      
                      # 如果没有提取到详细链接，使用当前页面URL
                      if not detail_url:
                          detail_url = current_url
                      
                      titles_with_links.append((title_text, detail_url))
                  
                  print(f"成功提取 {len(titles_with_links)} 个项目标题")
                  return titles_with_links

              def get_content_hash(self, url):
                  """获取内容哈希值 - 专注于项目内容本身，忽略顺序"""
                  try:
                      response = self.session.get(
                          url,
                          headers={'User-Agent': USER_AGENT, 'Cache-Control': 'no-cache'},
                          timeout=10
                      )
                      response.raise_for_status()
                      
                      # 提取所有项目标题和链接，基于这些内容计算哈希
                      titles_with_links = self.extract_project_titles(response.text, url)
                      
                      # 对项目标题进行排序，确保顺序不影响哈希值
                      sorted_titles = sorted([title for title, link in titles_with_links])
                      
                      # 只使用排序后的项目标题来计算哈希，忽略链接和顺序
                      content_for_hash = "\n".join(sorted_titles)
                      
                      print(f"使用排序后的项目标题计算哈希，内容长度: {len(content_for_hash)}")
                      return hashlib.sha256(content_for_hash.encode()).hexdigest(), response.text
                      
                  except Exception as e:
                      print(f"[ERROR] 检查 {url} 失败: {str(e)}")
                      return None, None

              def load_state(self):
                  """加载历史状态"""
                  try:
                      with open(STATE_FILE, 'r') as f:
                          state = json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      state = {}
                  
                  # 确保状态文件有正确的结构
                  for url in self.check_urls:
                      if url not in state:
                          state[url] = {"hash": None, "titles": []}
                      elif isinstance(state[url], str):  # 兼容旧版本的状态文件
                          state[url] = {"hash": state[url], "titles": []}
                  
                  return state

              def save_state(self, state):
                  """保存当前状态"""
                  try:
                      with open(STATE_FILE, 'w') as f:
                          json.dump(state, f, indent=2)
                  except IOError as e:
                      print(f"[ERROR] 保存状态失败: {str(e)}")

              def get_new_titles(self, current_titles, previous_titles):
                  """找出新增的标题"""
                  # 将之前的标题转换为集合以便快速查找
                  previous_set = set(previous_titles)
                  # 找出当前标题中不在之前标题集合中的项目
                  new_titles = [title for title in current_titles if title[0] not in previous_set]
                  
                  print(f"之前有 {len(previous_set)} 个项目，当前有 {len(current_titles)} 个项目，新增 {len(new_titles)} 个项目")
                  return new_titles

              def get_wechat_access_token(self):
                  """获取微信访问令牌"""
                  url = f"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={self.wechat_app_id}&secret={self.wechat_app_secret}"
                  try:
                      response = self.session.get(url, timeout=10)
                      response.raise_for_status()
                      result = response.json()
                      if 'access_token' in result:
                          return result['access_token']
                      else:
                          print(f"获取微信访问令牌失败: {result}")
                          return None
                  except Exception as e:
                      print(f"[ERROR] 获取微信访问令牌异常: {str(e)}")
                      return None

              def send_wechat_template_message(self, access_token, title, content, url_desc):
                  """发送微信模板消息"""
                  send_url = f"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={access_token}"
                  
                  # 构建模板数据
                  template_data = {
                      "touser": self.wechat_to_user,
                      "template_id": self.wechat_template_id,
                      "url": url_desc,  # 点击消息跳转的URL
                      "data": {
                          "title": {
                              "value": title,
                              "color": "#173177"
                          },
                          "content": {
                              "value": content,
                              "color": "#173177"
                          }
                      }
                  }
                  
                  try:
                      response = self.session.post(send_url, json=template_data, timeout=15)
                      response.raise_for_status()
                      result = response.json()
                      if result.get('errcode') == 0:
                          print(f"✅ 微信模板消息发送成功")
                          return True
                      else:
                          print(f"❌ 微信模板消息发送失败: {result.get('errmsg')}")
                          return False
                  except Exception as e:
                      print(f"[ERROR] 微信模板消息发送异常: {str(e)}")
                      return False

              def send_notifications(self, changed_urls, new_titles_map):
                  """发送通知到微信"""
                  access_token = self.get_wechat_access_token()
                  if not access_token:
                      print("无法获取微信访问令牌，通知发送失败")
                      return

                  for url in changed_urls:
                      desc = self.url_descriptions.get(url, "未知更新")
                      new_titles = new_titles_map.get(url, [])
                      
                      # 构建消息内容
                      title = f"🔔{desc}有更新"
                      content_lines = []
                      if new_titles:
                          for title_text, detail_url in new_titles:
                              content_lines.append(f"• {title_text}")
                          content_str = "\n".join(content_lines)
                      else:
                          content_str = "页面内容发生了变化，但没有检测到具体的新增项目。"
                      
                      # 发送模板消息
                      success = self.send_wechat_template_message(access_token, title, content_str, url)
                      if success:
                          print(f"已成功发送通知: {title}")
                      else:
                          print(f"发送通知失败: {title}")
                      time.sleep(1)  # 短暂延迟，避免频率过高

              def run(self):
                  """主执行流程"""
                  previous_state = self.load_state()
                  current_state = {}
                  changed_urls = []
                  new_titles_map = {}  # 存储每个URL对应的新增项目标题和链接

                  for url in self.check_urls:
                      print(f"\n检查 URL: {url}")
                      result = self.get_content_hash(url)
                      if result[0] is not None:
                          current_hash, html_content = result
                          # 提取当前所有标题
                          current_titles = self.extract_project_titles(html_content, url)
                          
                          # 获取之前的标题
                          previous_titles = previous_state.get(url, {}).get("titles", [])
                          
                          # 找出新增的标题
                          new_titles = self.get_new_titles(current_titles, previous_titles)
                          
                          # 准备当前状态存储
                          current_state[url] = {
                              "hash": current_hash,
                              "titles": [title[0] for title in current_titles]  # 只存储标题文本，不存储链接
                          }
                          
                          # 如果有新增标题或哈希值变化
                          previous_hash = previous_state.get(url, {}).get("hash")
                          if new_titles or previous_hash != current_hash:
                              changed_urls.append(url)
                              new_titles_map[url] = new_titles
                              print(f"URL {url} 检测到变化: 新增项目={len(new_titles)}个, 哈希变化={previous_hash != current_hash}")
                          else:
                              print(f"URL {url} 未检测到变化")
                          
                      time.sleep(1)  # 基础请求间隔

                  if changed_urls:
                      print(f"\n检测到 {len(changed_urls)} 项更新")
                      for url in changed_urls:
                          desc = self.url_descriptions.get(url, "未知更新")
                          new_titles = new_titles_map.get(url, [])
                          print(f"⭐ {desc}: {url}")
                          if new_titles:
                              for title, link in new_titles:
                                  print(f"  新增项目: {title} -> {link}")
                          else:
                              print("  页面内容有变化，但没有检测到新增项目")
                      
                      self.send_notifications(changed_urls, new_titles_map)
                      self.save_state(current_state)
                  else:
                      print("未检测到任何变化")

          if __name__ == "__main__":
              Monitor().run()
          EOF

      - name: Commit and push state file
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          if git diff --quiet url_state.json; then
            echo "No changes detected in url_state.json."
          else
            echo "Changes detected in url_state.json, preparing to commit..."
            git add url_state.json
            git commit -m "Update URL states [skip ci]" || echo "No changes to commit."
            git push origin HEAD || echo "Push failed, please check permissions or network issues."
            echo "状态文件已更新并提交"
          fi
