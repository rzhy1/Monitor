name: Monitor URL Changes

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 23,0-13 * * *'

permissions:
  contents: write

jobs:
  check_url_changes:
    runs-on: ubuntu-latest
    env:
      SCTKEY: ${{ secrets.SCTKEY }}
      WEBHOOK_URLS: ${{ secrets.WEBHOOK_URLS || '[]' }}
      CHECK_URLS: |
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511
        https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512
        https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxjhfb
        https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxygs
        https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxwj
      URL_DESCRIPTIONS: |
        {
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2331": "杭州地铁招标计划发布",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=2332": "杭州地铁招标预公示",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3508": "杭州地铁特别提醒项目",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3509": "杭州地铁招标核准项目",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3510": "杭州地铁招标文件公示",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3511": "杭州地铁中标公示",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/search/queryContents.jhtml?titleOrCode=%E5%9F%8E%E5%B8%82%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A&status=5&channelId=3512": "杭州地铁中标结果",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxjhfb": "杭州建设项目招标计划发布",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxygs": "杭州建设项目招标预公示",
          "https://ztb.cxjw.hangzhou.gov.cn:8092/jyxxwj": "杭州建设项目招标文件公示"
        }

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install aiohttp aiohttp-retry beautifulsoup4 lxml requests

      - name: Run URL monitor
        env:
          PYTHONUNBUFFERED: 1
        run: |
          python - << "EOF"
          import os
          import json
          import hashlib
          import asyncio
          import aiohttp
          from aiohttp_retry import RetryClient, ExponentialRetry
          from bs4 import BeautifulSoup
          from typing import Dict, List, Optional

          # 常量配置 <button class="citation-flag" data-index="7">
          USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
          STATE_FILE = "url_state2.json"
          CLEAN_TAGS = ['script', 'style', 'nav', 'footer', 'aside', 'header']
          CONTENT_SELECTORS = [
              ('div', {'class': 'menu menu_time'}),
              ('div', {'id': 'main-content'}),
              ('section', {'role': 'main'})
          ]

          class Monitor:
              def __init__(self):
                  self.session = None  # 延迟初始化
                  self.url_descriptions = json.loads(os.getenv("URL_DESCRIPTIONS", "{}"))
                  self.check_urls = [u.strip() for u in os.getenv("CHECK_URLS", "").splitlines()]
              
              async def create_session(self):
                  retry = ExponentialRetry(attempts=5, factor=2, statuses={429, 500, 502, 503, 504})
                  return RetryClient(
                      client_session=aiohttp.ClientSession(
                          headers={'User-Agent': "Mozilla/5.0"},
                          timeout=aiohttp.ClientTimeout(total=15)
                      ),
                      retry_options=retry
                  )

              async def clean_content(self, html: str) -> str:
                  """清理并提取主要内容 <button class="citation-flag" data-index="5">"""
                  soup = BeautifulSoup(html, 'lxml')  # 使用lxml加速解析
        
                  # 移除干扰元素
                  for tag in CLEAN_TAGS:
                      for element in soup.find_all(tag):
                          element.decompose()
        
                  # 定位主要内容区域
                  main_content = None
                  for selector in CONTENT_SELECTORS:
                      main_content = soup.find(*selector)
                      if main_content: break
        
                  return (main_content or soup).get_text('\n', strip=True)

              async def get_content_hash(self, url):
                  if not self.session:
                      self.session = await self.create_session()
        
                  try:
                      async with asyncio.timeout(10):  # 超时管理 <button class="citation-flag" data-index="9">
                          async with self.session.get(url) as response:
                              response.raise_for_status()
                              html = await response.text()
                              cleaned = self.clean_content(html)
                              return hashlib.sha256(cleaned.encode()).hexdigest()
                  except Exception as e:
                      print(f"[ERROR] 检查 {url} 失败: {str(e)}")
                      return None

              async def check_urls_async(self) -> Dict[str, str]:
                  """并发检查所有URL <button class="citation-flag" data-index="1"><button class="citation-flag" data-index="8">"""
                  tasks = [self.get_content_hash(url) for url in self.check_urls]
                  results = await asyncio.gather(*tasks)
                  return {url: hash_val for url, hash_val in zip(self.check_urls, results) if hash_val}

              def load_state(self) -> Dict[str, str]:
                  """加载历史状态文件 <button class="citation-flag" data-index="6">"""
                  try:
                      with open(STATE_FILE, 'r') as f:
                          return json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      return {}

              def save_state(self, state: Dict[str, str]) -> None:
                  """仅在变化时保存状态 <button class="citation-flag" data-index="6">"""
                  try:
                      with open(STATE_FILE, 'w') as f:
                          json.dump(state, f, indent=2)
                  except IOError as e:
                      print(f"[ERROR] 保存状态失败: {str(e)}")

              async def send_webhooks(self, items: List[str], webhooks: List[str]) -> None:
                  """并发发送企业微信通知 <button class="citation-flag" data-index="3">"""
                  async with aiohttp.ClientSession() as session:
                      tasks = []
                      for webhook in webhooks:
                          payload = {
                              "msgtype": "markdown",
                    "markdown": {
                                  "content": "### 更新通知\n" + "\n".join(items)
                              }
                          }
                          task = session.post(webhook, json=payload)
                          tasks.append(task)
            
                      responses = await asyncio.gather(*tasks, return_exceptions=True)
                      for resp, webhook in zip(responses, webhooks):
                          if isinstance(resp, Exception):
                              print(f"[ERROR] Webhook {webhook} 发送失败: {str(resp)}")
                          elif resp.status == 200:
                              print(f"企业微信通知成功: {webhook}")
                          else:
                              print(f"[ERROR] Webhook {webhook} 状态码: {resp.status}")

              def send_serverchan(self, content: str) -> None:
                  """同步发送Server酱通知（保持简单）"""
                  if not (sctkey := os.getenv("SCTKEY")):
                      return
        
                  try:
                      response = requests.post(
                          f"https://sctapi.ftqq.com/{sctkey}.send",
                          json={'title': '内容更新', 'desp': content[:2000]},
                          timeout=15
                      )
                      response.raise_for_status()
                      print("Server酱通知成功")
                  except Exception as e:
                      print(f"[ERROR] Server酱通知失败: {str(e)}")

              async def send_notifications(self, changed_urls: List[str]) -> None:
                  """统一通知入口 <button class="citation-flag" data-index="2">"""
                  plain_msg = []
                  markdown_msg = []
                  for url in changed_urls:
                      desc = self.url_descriptions.get(url, "未知更新")
                      plain_msg.append(f"{desc}: {url}")
                      markdown_msg.append(f"[{desc}]({url})")

                  # 并发发送所有通知
                  await asyncio.gather(
                      self.send_serverchan("\n\n".join(plain_msg)),
                      self.send_webhooks(markdown_msg, json.loads(os.getenv("WEBHOOK_URLS", "[]")))
                  )

              async def run(self) -> None:
                  """主执行流程 <button class="citation-flag" data-index="4">"""
                  previous_state = self.load_state()
                  current_state = await self.check_urls_async()
                  changed_urls = [url for url in current_state if current_state[url] != previous_state.get(url)]

                  if changed_urls:
                      print(f"检测到 {len(changed_urls)} 项更新:")
                      for url in changed_urls:
                          print(f"⭐ {self.url_descriptions.get(url, '未知更新')}: {url}")
            
                      await self.send_notifications(changed_urls)
                      self.save_state(current_state)
                  else:
                      print("未检测到变化")

          if __name__ == "__main__":
              # 使用asyncio运行主函数 <button class="citation-flag" data-index="8">
              asyncio.run(Monitor().run())
          EOF

      - name: Commit state changes
        if: github.event_name != 'pull_request'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add url_state2.json
            git commit -m "Automated update: URL state changes [skip ci]"
            git push origin HEAD || echo "Push failed, check permissions"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
